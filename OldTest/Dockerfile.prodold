# Use the official Golang image to create a build artifact.
FROM golang:latest AS builder

# Set the working directory inside the container.
WORKDIR /app

# Declare the environment variables
ARG DB_USER
ARG DB_PASSWORD
ARG DB_HOST
ARG DB_PORT
ARG DB_NAME
ARG DB_URL
ARG STORAGE_ENDPOINT
ARG STORAGE_ACCESS_KEY
ARG STORAGE_SECRET_KEY
ARG STORAGE_BUCKET
ARG CORS_ORIGIN
ARG AUTH0_DOMAIN
ARG AUTH0_AUDIENCE
ARG URL_HOST

# Copy go.mod and go.sum to download dependencies.
COPY go.mod go.sum ./

# Download all dependencies.
RUN go mod download

# Copy the source code into the container.
COPY . .

# Build the Go app for production
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./cmd

# Start a new stage from scratch
FROM alpine:latest

# Copy the environment variables
ENV DB_USER=$DB_USER
ENV DB_PASSWORD=$DB_PASSWORD
ENV DB_HOST=$DB_HOST
ENV DB_PORT=$DB_PORT
ENV DB_NAME=$DB_NAME
ENV DB_URL=$DB_URL
ENV STORAGE_ENDPOINT=$STORAGE_ENDPOINT
ENV STORAGE_ACCESS_KEY=$STORAGE_ACCESS_KEY
ENV STORAGE_SECRET_KEY=$STORAGE_SECRET_KEY
ENV STORAGE_BUCKET=$STORAGE_BUCKET
ENV CORS_ORIGIN=$CORS_ORIGIN
ENV AUTH0_DOMAIN=$AUTH0_DOMAIN
ENV AUTH0_AUDIENCE=$AUTH0_AUDIENCE
ENV URL_HOST=$URL_HOST

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# Copy the pre-built binary file from the previous stage
COPY --from=builder /app/main .

# Expose port 8080 to the outside world
EXPOSE 8080

# Run the binary program
CMD ["./main"]